Tìm hiểu về PX4
Ground Control Station là gì ? (tay cầm)(https://docs.qgroundcontrol.com/master/en/qgc-user-guide/)
- Đọc cả SIYI MK32
Trên drone thường sẽ có những bộ phận nào
Giao thức thường được sử dụng là gì? (MAVlink)(CAN ESC)(https://docs.px4.io/main/en/can/)
Để điều khiển drone cần những thông tin về dữ kiện gì ? (Telemetry)(height,weight)(elrs)(ARK Flow, VectorNav)
Drone có những kiểu điều khiển như thế nào  (throttle, yaw, pitch, ..)
Tìm hiểu xem Drone thường sử dụng những dải tần nào để điều khiển ?
Lợi ích, tác hại của những dải tần?
giao thức truyền video về ? (rtsp protocol)(telemetry 2.4GHZ ,RC)
tài liệu tham khảo
https://px4.io/software/software-overview/
nó được cộng đồng phát triển trên nền tảng chip STM32H7
https://docs.holybro.com/autopilot/pixhawk-baseboards/pixhawk-jetson-baseboard/overview-and-specification
https://docs.px4.io/main/en/concept/architecture
https://docs.px4.io/main/en/concept/px4_systems_architecture.html
https://docs.px4.io/main/en/flight_stack/controller_diagrams.html
https://docs.px4.io/main/en/can/
https://docs.px4.io/main/en/companion_computer/holybro_pixhawk_jetson_baseboard.html
-PX4 Là gì :

+PX4 là phần mềm điều khiển bay nguồn mở dành cho máy bay không người lái (drone) và các phương tiện không người lái khác. Dự án cung cấp một bộ công cụ linh hoạt cho phép các nhà phát triển drone chia sẻ công nghệ, từ đó tạo ra các giải pháp phù hợp cho các ứng dụng drone. PX4 cung cấp một tiêu chuẩn để cung cấp hỗ trợ phần cứng và phần mềm cho drone, cho phép một hệ sinh thái xây dựng và bảo trì phần cứng và phần mềm một cách linh hoạt.

-tại sao các nhà phát triển PX4:

+kiến trúc Mô Đun 
PX4 có tính mô-đun hóa cao và khả năng mở rộng cả về phần cứng lẫn phần mềm. Nó sử dụng kiến trúc dựa trên cổng - nghĩa là khi các nhà phát triển thêm các thành phần, hệ thống mở rộng không bị mất đi tính mạnh mẽ hay hiệu suất.

+nguồn mở 
PX4 được phát triển đồng thời với một cộng đồng phát triển toàn cầu. Flightstack không chỉ đáp ứng nhu cầu của một phòng thí nghiệm hay một công ty, mà còn được thiết kế như một bộ công cụ chung và được sử dụng rộng rãi trong ngành.

+khả năng cấu hình 
PX4 cung cấp các API và SDK được tối ưu hóa cho các nhà phát triển làm việc với tích hợp. Tất cả các mô-đun đều độc lập và có thể dễ dàng chuyển đổi sang một mô-đun khác mà không cần sửa đổi lõi. Các tính năng dễ dàng triển khai và cấu hình lại.

+ngăn xếp tự động 
PX4 được thiết kế để kết hợp chặt chẽ với thị giác máy tính nhúng nhằm mang lại khả năng tự động hóa. Nền tảng này giúp giảm thiểu rào cản gia nhập cho các nhà phát triển đang nghiên cứu các thuật toán định vị và phát hiện chướng ngại vật.

- các bộ phận trên drone
+----------------------------------------------------+
|                Khung (Frame)                       |
|  |-- Động cơ + Cánh quạt --|                       |
|  |-- ESC (điều khiển động cơ)                      |
|  |-- Pin (Battery)                                 |
|  |-- Flight Controller (PX4, Pixhawk...)           |
|      |-- IMU (Gyro + Accel)                        |
|      |-- Compass                                   |
|      |-- Barometer                                 |
|  |-- GPS Module                                    |
|  |-- Telemetry Module + Anten                      |
|  |-- Camera + Gimbal (nếu có)                      |
|  |-- RC Receiver                                   |
|  |-- LED, Buzzer                                   |
|  |-- Cảm biến bổ sung (Lidar, Sonar, Optical Flow)

- trên drone thường có những bộ phận :
+
1. Joystick / Stick (Cần điều khiển)
2. Công tắc / Switch
3. Núm xoay / Potentiometer
4. Màn hình hiển thị
5. Ăng-ten (Antenna)
6. Cổng kết nối (USB, Trainer port, module mở rộng...)
7. Pin / Battery
8. Buzzer / Loa
9. Đèn LED trạng thái


- quy trình truyền tín hiệu lên drone PX4
Quy trình truyền tín hiệu lên drone PX4
Các bộ phận nhập liệu (joystick, switch, núm xoay) → Vi điều khiển tay cầm

Vi điều khiển đọc các giá trị và trạng thái, đóng gói thành bản tin điều khiển (theo giao thức: SBUS, CRSF, PPM...).
Vi điều khiển → Module  → Ăng-ten phát sóng

Bản tin điều khiển được mã hóa và phát qua sóng RF tới drone.
Drone (receiver) → Giải mã tín hiệu → PX4 Flight Controller

Bộ thu tín hiệu trên drone nhận, giải mã, chuyển tới PX4.
PX4 xử lý lệnh

PX4 nhận lệnh, điều khiển động cơ, gimbal, camera, chế độ bay...
Telemetry (nếu có)

PX4 gửi thông tin trạng thái, vị trí, pin... về tay cầm, hiển thị trên màn hình, cảnh báo cho người dùng.
Ví dụ thực tế:

Khi bạn gạt joystick lên, vi điều khiển tay cầm chuyển thành kênh throttle, mã hóa và phát sóng RF. Drone nhận, PX4 tăng tốc động cơ để drone bay lên.
Khi bạn bật công tắc “Return to Home”, tay cầm gửi tín hiệu chế độ về PX4, PX4 tự động điều khiển drone bay về vị trí xuất phát.

- dải tần để điều khiển 
+ 900 MHz / 868 MHz
Dành cho các hệ thống điều khiển tầm xa (long range) như Crossfire, ELRS, R9M...
900 MHz thường dùng ở Mỹ; 868 MHz dùng ở châu Âu (theo quy định vùng).
Khoảng cách truyền: Có thể lên tới hàng chục km, xuyên vật cản tốt hơn 2.4 GHz.

- dải tần để truyền video live về
+ Truyền bằng tín hiệu radio (2.4 GHz) dải tần rộng phạm vi xa (module ELRS (ExpressLRS))
hạn chế của dải tần này là có độ trễ tín hiệu truyền sóng kém không ổn định bằng 5.8 GHZ
cho video chất lượng thấp tụt fps
* cách khắc phục có thể thay bằng sóng 5.8ghz để tín hiệu được ổn định
hạn chế của cách này là (đường truyền hẹp , phạm vi ngắn )

-(truyền telemetry, truyền video), hãy nói rõ hơn để mình tư vấn chi tiết!
Telemetry (viễn trắc) là quá trình thu thập và truyền dữ liệu từ một thiết bị ở xa (ví dụ: drone, vệ tinh, cảm biến...) về máy chủ hoặc thiết bị điều khiển trung tâm để giám sát, phân tích và điều khiển.

Trong drone PX4, telemetry thường là các thông tin như:

Vị trí, tốc độ, độ cao
Tình trạng pin, GPS
Trạng thái bay, lỗi hệ thống
Dữ liệu cảm biến (IMU, khí áp, v.v.)
Dữ liệu này được truyền về mặt đất qua sóng radio, WiFi, hoặc các giao thức như MAVLink để người dùng có thể theo dõi và điều khiển drone từ xa.
Telemetry tương tự như một hệ thống giám sát từ xa hoặc truyền dữ liệu tự động.
Bạn có thể hình dung nó giống như:

Hộp đen máy bay: Ghi lại và truyền dữ liệu chuyến bay về trung tâm để phân tích.
Đồng hồ thông minh: Gửi dữ liệu sức khỏe của bạn về điện thoại.
Cảm biến thời tiết tự động: Gửi số liệu nhiệt độ, độ ẩm về trạm khí tượng.
Tóm lại, telemetry là cách thiết bị tự động gửi dữ liệu về cho người dùng hoặc hệ thống giám sát mà không cần thao tác thủ công.


- thuật toán điều khiển drone https://docs.px4.io/main/en/flight_stack/controller_diagrams.html
+ PID :
2. PID được sử dụng ở đâu trong drone?
Điều khiển attitude (góc nghiêng: roll, pitch, yaw).
Giữ vị trí, độ cao (position, altitude).
Điều khiển tốc độ động cơ.

3. Nguyên lý hoạt động PID trong drone
Drone nhận lệnh (ví dụ: nghiêng sang trái, bay lên, quay đầu).
Cảm biến (IMU, gyro, accelerometer) đo trạng thái hiện tại (góc, vị trí, tốc độ).
PID controller so sánh trạng thái hiện tại với trạng thái mong muốn (setpoint).
Tính toán sai số (error = setpoint - actual value).
Ba thành phần PID xử lý sai số:
P (Proportional): Điều chỉnh nhanh theo sai số tức thời.
I (Integral): Bù trừ sai số tích lũy (lâu dài).
D (Derivative): Dự đoán và giảm rung lắc bằng cách xét tốc độ thay đổi sai số.
Kết quả PID là tín hiệu điều chỉnh gửi đến động cơ (ESC), giúp drone đạt trạng thái mong muốn.

+. Quaternion Attitude Control (Điều khiển tư thế bằng quaternion)
Được mô tả trong phần mô tả file và tài liệu tham khảo:
Nonlinear Quadrocopter Attitude Control (2013) by Dario Brescianini, Markus Hehn and Raffaello D'Andrea.
Thuật toán này sử dụng quaternion để điều khiển tư thế (attitude) của drone, giúp tránh các vấn đề về singularity (góc Euler).
Được triển khai trong hàm generate_attitude_setpoint và các hàm liên quan đến attitude control.

-các giao tiếp trong drone tới bo mạch :
https://docs.px4.io/main/en/companion_computer/holybro_pixhawk_jetson_baseboard


-sơ đồ điều khiển PX4 từ PID đến động cơ :
+------------------+
|  Rate Controller |   ← PID tính toán moment
| (Roll, Pitch, Yaw) |
+------------------+
          ↓
     torque_sp (Nm)   ← moment mong muốn
          ↓
+------------------+
|      Mixer       |   ← ánh xạ torque thành lực động cơ
+------------------+
          ↓
   motor_output (PWM) ← giá trị từ 1000 - 2000 µs
          ↓
+------------------+
|      ESC         |   ← chuyển PWM thành dòng điện
+------------------+
          ↓
+------------------+
|    Động cơ       |   ← tạo lực quay + lực nâng
+------------------+


Ví dụ:
Interface	Mô tả
UART (Universal Asynchronous Receiver/Transmitter)	Giao tiếp nối tiếp, thường dùng giữa vi điều khiển và cảm biến/module
I2C (Inter-Integrated Circuit)	Giao tiếp nối tiếp hai dây (SDA, SCL)
SPI (Serial Peripheral Interface)	Giao tiếp nối tiếp bốn dây (MOSI, MISO, SCLK, SS)
USB	Giao diện phổ biến giữa máy tính và thiết bị ngoại vi
GPIO	Giao diện đầu vào/ra số đơn giản

→ Interface quy định phần cứng kết nối, số dây, cách đấu nối, và đặc tính điện học (mức điện áp, tốc độ, v.v.).

📡 2. Protocol (Giao thức) là gì?
Protocol là tập hợp các quy tắc và định dạng dữ liệu để các thiết bị trao đổi thông tin với nhau thông qua một interface.

Nó mô tả:

Cách bắt đầu/kết thúc giao tiếp

Cách định dạng dữ liệu

Cách kiểm tra lỗi

Cách đồng bộ hóa

Ví dụ:
Protocol	Mô tả
I2C protocol	Gồm start bit, address, R/W bit, ACK/NACK, stop bit
SPI protocol	Định nghĩa thứ tự gửi bit (MSB/LSB), thời điểm chốt dữ liệu
Modbus	Giao thức công nghiệp hoạt động qua RS-485 hoặc TCP/IP
CAN protocol	Giao thức cho hệ thống nhúng ô tô, truyền qua bus CAN
USB protocol	Phức tạp, hỗ trợ lớp device class (audio, mass storage, HID...)

→ Protocol nằm ở tầng logic hoặc phần mềm, điều khiển cách thiết bị hiểu và xử lý dữ liệu.
đây là 2 khái niệm quan trọng trong hệ thống phần cứng
em cần nắm rõ và hiểu sâu


MAVlink là một giao thức sử dụng Telemetry radio để gửi tín hiệu lên máy bay bằng cách tạo 1 vỏ bọc bên ngoài rồi bọc lấy tín hiệu cần phải gửi và tín hiệu này sẽ được mavlink gói lại sau đó gửi lên máy bay 
telemetry radio gửi tín hiệu lên máy bay bằng cách đồng bộ giải tần muốn gửi lên máy bay nào thì dải tần phải giống với máy bay đó



I2C :
Start condition :
Là tín hiệu bắt đầu giao tiếp I2C
Do thiết bị master phát ra 
Không phải là 1 bit dữ liệu mà là tín hiệu điều khiển đặc biệt
Cách tạo tín hiệu Start :
Start condition xảy ra khi :
SDA chuyển từ HIGH -> LOW trong khi SCL đang HIGH [giống với kiểu master bảo slave chuẩn bị nghe nó nói và slave nếu đã sẵn sàng nghe master nói thì truyền lại ACK ( vâng)]
vai trò của start bit :
Đồng bộ - Báo hiệu cho tất cả thiết bị trên bus rằng một dữ liệu truyền mới bắt đầu
Xác định master - Master là một thiết bị phát Start
Bắt đầu truyền - Ngay sau Start, master sẽ gửi địa chỉ + R/W

Địa chỉ 7-bit tùy vào module hỗ trợ từ bao nhiêu đến bao nhiêu 
ví dụ LM75 hỗ trợ từ 0x48 đến 0x4F với các chân từ 1001A2A1A0 tùy bên phía nhà sản xuất thì có thể là (AX) có thể là 0 hoặc 1 để xác định địa chỉ 
A2	A1	A0	Địa chỉ nhị phân	Địa chỉ HEX
0	0	0	1001000	             0x48
0	0	1	1001001	             0x49
0	1	0	1001010	             0x4A
0	1	1	1001011	             0x4B
1	0	0	1001100	             0x4C
1	0	1	1001101	             0x4D
1	1	0	1001110	             0x4E
1	1	1	1001111	             0x4F

R/W:
(read/write) trong giao thức I2C là 1 bit rất quan trọng . Nó nằm ngay sau byte địa chỉ và cho phép vi điều khiển (MCU) cho biết là nó muốn đọc dữ liệu từ thiết bị hay ghi dữ liệu vào thiết bị 
[7-bit địa chỉ thiết bị ] + [ 1-bit R/W]
0 -> ghi dữ liệu vào thiết bị (Write)
1 -> Đọc dữ liệu từ thiết bị (Read)
Wire.beginTransmission(LM75_ADDRESS); // Start condition + gửi địa chỉ + R/W = 0

Wire.requestFrom(LM75_ADDRESS, 2);   // Start condition + địa chỉ + R/W = 1

ACK: là tín hiệu phản hồi 
sau khi nhận đúng địa chỉ báo ACK ((thiết bị nhận dữ liệu thành công)Acknowledge)
SDA khi nào bằng LOW thì là tín hiệu báo ACK (đã nhận thành công) và muốn nhận thêm
tín hiệu phản hồi ACK tới từ SLAVE 
giống như việc master ra lệnh làm việc đi và slave có nhiệm vụ gửi ACK ( đã rõ thưa ngài )
còn nếu không nghe lời hoặc đã làm đủ rồi thì slave có nhiệm vụ gửi NACK ( tôi đã làm rồi và không làm nữa or tôi không làm nữa thưa ngài )
nếu slave vâng lời thì SDA sẽ về LOW khi đối chiếu với SCL
còn slave không vâng lời thì SDA sẽ về HIGH khi đối chiếu với SCL khi mà cả 2 tín hiệu này đều gửi về
ACK và NACK là bit thứ 9 được nhét sau cùng bit thứ 8 khi gửi 1 byte dữ liệu
nếu không có ACK or NACK gửi về có thể coi là coi là SLAVE bị điếc ( trục trặc kết nối )  hoặc không có SLAVE để nghe lệnh , hoặc SLAVE chưa sẵn sàng có nhiều nguyên nhân chưa sẵn sàng có thể do mạch điện đang không ổn định , quá nhiệt , quá tải , trục trặc về linh kiện gắn trên SLAVE 

SCL và SDA 
SCL được coi như là một vị tướng được master tạo ra với mục đích sắp xếp vị trí từng bit 1 cho nó đi đúng lộ trình và thời điểm byte này được truyền đi 
SDA là nơi được coi như là đường truyền dữ liệu bao gồm dữ liệu từ thanh ghi và đọc của Master khi kết nối với SLAVE cho phép master ra chỉ thị cho slave và slave phản hồi lại master về quá trình công việc giống như việc bạn phản hồi lại sếp của bạn khi bạn nhận được nhiệm vụ là như thế nào ở đây thì SDA cho phép Master và slave được tự do ngôn luận

stop bit : 
được khởi động sau khi start bit và là tín hiệu cuối cùng 
để kết thúc 1 byte dữ liệu 
tương tự như start bit thì stop bit có phần ngược lại so với start là nó sẽ nhảy 1 bit từ LOW lên HIGH khi SCL đang HIGH

SPI :
sơ lược :
SPI có các chân MOSI ( master out slave in ) MISO ( master in slave out )
sclk chân xung clock nó giống như cách start khi mà cô giáo gõ lên bảng thì học sinh bên dưới đọc hoặc phát biểu nghĩa là mỗi lần chân phát xung đó phát xung thì slave mới được làm nó cũng như nhịp đập của tim khi có nhịp đập thì giao thức mới làm việc 
ss chân truyền data sẽ có lần lượt ss1 ss2 ss3 ... ssn 
ss nhằm có mục đích đó là cho data truyền đi đúng slave cần truyền nhiệm vụ tránh cho việc điều khiển bị rối
spi có một nhược điểm số lượng dây kết nối rất nhiều và hiệu quả nhất là khi các slave ở gần 

Các thành phần chính của SPI
Master: Thiết bị điều khiển quá trình giao tiếp.
Slave: Thiết bị nhận lệnh và gửi dữ liệu khi được master yêu cầu.
SCK (Serial Clock): Đường xung clock do master tạo ra để đồng bộ hóa việc truyền dữ liệu.
MOSI (Master Out Slave In): Đường dữ liệu từ master đến slave.
MISO (Master In Slave Out): Đường dữ liệu từ slave về master.
SS/CS (Slave Select/Chip Select): Đường tín hiệu do master điều khiển để chọn slave nào sẽ giao tiếp.
Quá trình gửi một byte dữ liệu trong SPI

Chọn Slave:
Để bắt đầu giao tiếp với một slave cụ thể, master sẽ kéo đường SS/CS tương ứng của slave đó xuống mức thấp (logic 0).
Các slave khác trên bus không được chọn sẽ giữ đường SS/CS của chúng ở mức cao và không tham gia vào quá trình truyền dữ liệu.

Đồng bộ hóa và gửi dữ liệu:
Master bắt đầu tạo ra các xung clock trên đường SCK.
Trong mỗi chu kỳ xung clock, master sẽ đẩy một bit dữ liệu ra đường MOSI và đồng thời đọc một bit dữ liệu từ đường MISO. Cùng lúc đó, slave sẽ đọc bit từ MOSI và đẩy một bit dữ liệu của nó ra MISO.
Quá trình này diễn ra tuần tự, thường bắt đầu với bit có trọng số cao nhất (MSB) trước. Để gửi một byte (8 bit), quá trình này sẽ lặp lại trong 8 chu kỳ clock.

Trao đổi dữ liệu:
Giả sử master muốn gửi byte 0x55 (01010101) đến slave.
Trong chu kỳ clock đầu tiên, master gửi bit 0 trên MOSI và đọc một bit từ MISO.
Trong chu kỳ clock thứ hai, master gửi bit 1 và đọc bit tiếp theo.
Quá trình này tiếp tục cho đến hết 8 bit. Sau 8 chu kỳ clock, master đã gửi xong byte 0x55 và đồng thời đã nhận được một byte dữ liệu từ slave.
Điều này là điểm khác biệt lớn nhất so với I2C: dữ liệu luôn được trao đổi hai chiều trong cùng một quá trình, ngay cả khi master chỉ muốn "ghi" (gửi) dữ liệu. Master có thể bỏ qua dữ liệu nhận được nếu không cần.

Kết thúc quá trình:
Sau khi master gửi đủ số byte cần thiết, nó sẽ ngừng tạo xung clock trên đường SCK và kéo đường SS/CS trở lại mức cao (logic 1) để kết thúc phiên giao tiếp với slave đó.
Điều này giải phóng slave để nó sẵn sàng cho các giao tiếp tiếp theo, có thể là với một master khác hoặc với cùng một master nhưng trong một phiên mới.


CAN :
hiểu đơn giản nó sẽ có 2 đường truyền CAN RX và TX 
RX thì thành LOW còn TX thì thành thành HIGH 
nếu ở mức logic 0 thì 
Can H sẽ nhảy lên 3.5V 
Can L sẽ xuống 0V
còn nếu ở mức logic 1
Can L ,H lên xuống còn 2.5V không có sự chênh lệch điện áp thì ở trạng thái không truyền dữ liệu
CAN to ECU :
được hiểu như là dữ liệu từ CAN truyền qua ECU thì sẽ nhận dạng ECU đó thông qua ID 


Dưới đây là một số cách mà PX4 xử lý lỗi giao thức:

Cơ chế xử lý lỗi theo từng giao thức
DroneCAN: Giao thức này cực kỳ mạnh mẽ. Nó sử dụng các gói tin có checksum (mã kiểm tra lỗi) để đảm bảo dữ liệu không bị hỏng trong quá trình truyền. Nếu một gói tin bị lỗi, nó sẽ bị loại bỏ. Ngoài ra, giao thức CAN Bus còn có khả năng tự động ngắt kết nối các thiết bị bị lỗi trên bus để tránh làm ảnh hưởng đến toàn bộ mạng.

I2C và SPI: Các giao thức này có cơ chế kiểm soát lỗi đơn giản hơn. I2C có bit ACK (Acknowledge) để xác nhận việc nhận dữ liệu, nhưng không có tính năng chống nhiễu mạnh mẽ như CAN Bus. Nếu có lỗi, PX4 sẽ cố gắng đọc lại dữ liệu hoặc báo lỗi cảm biến.

UART: Đây là giao thức cơ bản nhất, thường không có cơ chế sửa lỗi tích hợp. Nếu dữ liệu bị hỏng, PX4 sẽ nhận được dữ liệu sai và có thể dẫn đến hành vi không mong muốn.

Cơ chế an toàn tổng thể (Failsafe) của PX4
Đây là cơ chế quan trọng nhất để gỡ lỗi và phục hồi hệ thống, không chỉ giới hạn ở giao thức. Nếu một giao thức gặp lỗi nghiêm trọng (ví dụ: mất kết nối với GPS hoặc bộ thu sóng), PX4 sẽ tự động kích hoạt các hành động an toàn (failsafe) đã được người dùng cài đặt trước, bao gồm:

Chế độ giữ vị trí (Hold): Drone sẽ giữ nguyên vị trí hiện tại.

Quay về điểm xuất phát (Return): Drone sẽ tự động quay trở lại điểm cất cánh.

Hạ cánh khẩn cấp (Land): Drone sẽ hạ cánh tại vị trí hiện tại.

Những cơ chế này giúp hệ thống tự động gỡ lỗi một cách an toàn và phục hồi sau khi gặp sự cố, đảm bảo drone không gặp tai nạn do lỗi giao tiếp.




